"""
Signal generation for trading
"""

from dataclasses import dataclass, field
from typing import List, Optional, Dict, Any
from enum import Enum
from datetime import datetime


class SignalType(Enum):
    WAVE3_LONG = "wave3_long"
    WAVE3_SHORT = "wave3_short"
    WAVE5_LONG = "wave5_long"
    WAVE5_SHORT = "wave5_short"
    ZIGZAG_LONG = "zigzag_long"
    ZIGZAG_SHORT = "zigzag_short"
    FLAT_LONG = "flat_long"
    FLAT_SHORT = "flat_short"
    TRIANGLE_LONG = "triangle_long"
    TRIANGLE_SHORT = "triangle_short"


@dataclass
class Signal:
    """Trading signal generated by strategy"""
    signal_type: SignalType
    timestamp: datetime
    bar_index: int
    entry_price: float
    stop_loss: float
    take_profit_1: float
    take_profit_2: float

    # Additional info
    fib_level_hit: Optional[float] = None
    confidence: float = 1.0
    module: str = ""  # A, B, or C
    is_confirmation_entry: bool = False  # Stage 1 or Stage 2

    # Wave context
    wave_context: Dict[str, Any] = field(default_factory=dict)

    @property
    def is_long(self) -> bool:
        return self.signal_type.value.endswith('_long')

    @property
    def risk_per_unit(self) -> float:
        return abs(self.entry_price - self.stop_loss)

    @property
    def reward_1(self) -> float:
        return abs(self.take_profit_1 - self.entry_price)

    @property
    def reward_2(self) -> float:
        return abs(self.take_profit_2 - self.entry_price)

    @property
    def risk_reward_1(self) -> float:
        if self.risk_per_unit == 0:
            return 0
        return self.reward_1 / self.risk_per_unit

    @property
    def risk_reward_2(self) -> float:
        if self.risk_per_unit == 0:
            return 0
        return self.reward_2 / self.risk_per_unit


class SignalGenerator:
    """
    Coordinates signal generation from all modules
    """

    def __init__(
        self,
        module_a_enabled: bool = True,
        module_b_enabled: bool = True,
        module_c_enabled: bool = True,
        min_risk_reward: float = 2.0
    ):
        self.module_a_enabled = module_a_enabled
        self.module_b_enabled = module_b_enabled
        self.module_c_enabled = module_c_enabled
        self.min_risk_reward = min_risk_reward

    def filter_signals(self, signals: List[Signal]) -> List[Signal]:
        """
        Filter signals based on quality criteria

        Args:
            signals: List of raw signals

        Returns:
            Filtered list of signals
        """
        filtered = []

        for signal in signals:
            # Check minimum risk/reward
            if signal.risk_reward_1 < self.min_risk_reward:
                continue

            # Check module enabled
            if signal.module == 'A' and not self.module_a_enabled:
                continue
            if signal.module == 'B' and not self.module_b_enabled:
                continue
            if signal.module == 'C' and not self.module_c_enabled:
                continue

            filtered.append(signal)

        return filtered

    def deduplicate_signals(self, signals: List[Signal]) -> List[Signal]:
        """
        Remove duplicate signals at same bar/price

        Args:
            signals: List of signals

        Returns:
            Deduplicated signals
        """
        seen = set()
        unique = []

        for signal in signals:
            key = (signal.bar_index, signal.signal_type, round(signal.entry_price, 2))
            if key not in seen:
                seen.add(key)
                unique.append(signal)

        return unique
